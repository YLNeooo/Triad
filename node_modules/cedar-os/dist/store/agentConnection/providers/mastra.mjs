// src/store/agentConnection/agentUtils.ts
var processContentChunk = (rawChunk) => {
  return rawChunk.replace(/(\\n|\n)/g, "\n");
};
async function handleEventStream(response, handler) {
  if (!response.ok || !response.body) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  const completedItems = [];
  let currentTextMessage = "";
  const parseSSEEvent = (raw) => {
    let eventType = "message";
    let data = "";
    for (const line of raw.split("\n")) {
      if (line.startsWith("event:")) {
        eventType = line.slice(6).trim();
      } else if (line.startsWith("data:")) {
        data += line.slice(5);
      }
    }
    return { eventType, data };
  };
  const processDataContent = (data) => {
    if (data.trim() === "[DONE]" || data.trim() === "done") {
      return;
    }
    try {
      const parsed = JSON.parse(data);
      if (parsed === null || typeof parsed !== "object") {
        const processedContent = processContentChunk(String(parsed));
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
        return;
      }
      if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {
        const delta = parsed.choices[0].delta;
        if (delta.content) {
          const processedContent = processContentChunk(delta.content);
          currentTextMessage += processedContent;
          handler({ type: "chunk", content: processedContent });
        }
        if (delta.tool_calls || delta.function_call) {
          if (currentTextMessage.trim()) {
            completedItems.push(currentTextMessage.trim());
            currentTextMessage = "";
          }
          handler({ type: "object", object: delta });
          completedItems.push(delta);
        }
        if (Object.keys(delta).length === 0) {
          return;
        }
      }
      if (typeof parsed.content === "string" && parsed.content.length > 0) {
        const processedContent = processContentChunk(parsed.content);
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
      }
      if (parsed.type || parsed.object && parsed.object.type) {
        const structuredObject = parsed.type ? parsed : parsed.object;
        if (currentTextMessage.trim()) {
          completedItems.push(currentTextMessage.trim());
          currentTextMessage = "";
        }
        handler({ type: "object", object: structuredObject });
        completedItems.push(structuredObject);
      }
      if (!parsed.choices && !parsed.type && !(parsed.object && parsed.object.type) && !parsed.content) {
        if (currentTextMessage.trim()) {
          completedItems.push(currentTextMessage.trim());
          currentTextMessage = "";
        }
        handler({ type: "object", object: parsed });
        completedItems.push(parsed);
      }
    } catch {
      if (data && data !== "[DONE]" && data !== "done") {
        const processedContent = processContentChunk(data);
        currentTextMessage += processedContent;
        handler({ type: "chunk", content: processedContent });
      }
    }
  };
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let eventBoundary;
      while ((eventBoundary = buffer.indexOf("\n\n")) !== -1) {
        const rawEvent = buffer.slice(0, eventBoundary);
        buffer = buffer.slice(eventBoundary + 2);
        if (!rawEvent.trim()) continue;
        const { eventType, data } = parseSSEEvent(rawEvent);
        if (eventType.trim() === "done" || data.trim() === "[DONE]") {
          break;
        } else {
          processDataContent(data);
        }
      }
    }
    if (currentTextMessage.trim()) {
      completedItems.push(currentTextMessage.trim());
    }
    handler({ type: "done", completedItems });
  } catch (error) {
    handler({ type: "error", error });
    throw error;
  }
}

// src/store/agentConnection/providers/mastra.ts
var mastraProvider = {
  callLLM: async (params, config) => {
    const { route, prompt, systemPrompt, temperature, maxTokens, ...rest } = params;
    const headers = {
      "Content-Type": "application/json"
    };
    if (config.apiKey) {
      headers.Authorization = `Bearer ${config.apiKey}`;
    }
    const response = await fetch(`${config.baseURL}${route}`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        prompt,
        systemPrompt,
        temperature,
        maxTokens,
        ...rest
      })
    });
    return mastraProvider.handleResponse(response);
  },
  callLLMStructured: async (params, config) => {
    const {
      route,
      prompt,
      systemPrompt,
      temperature,
      maxTokens,
      schema,
      schemaName,
      schemaDescription,
      ...rest
    } = params;
    const headers = {
      "Content-Type": "application/json"
    };
    if (config.apiKey) {
      headers.Authorization = `Bearer ${config.apiKey}`;
    }
    const body = {
      prompt,
      systemPrompt,
      temperature,
      maxTokens,
      ...rest
    };
    if (schema) {
      body.schema = schema;
      body.schemaName = schemaName;
      body.schemaDescription = schemaDescription;
    }
    const response = await fetch(`${config.baseURL}${route}`, {
      method: "POST",
      headers,
      body: JSON.stringify(body)
    });
    return mastraProvider.handleResponse(response);
  },
  streamLLM: (params, config, handler) => {
    const abortController = new AbortController();
    const completion = (async () => {
      try {
        const { route, prompt, systemPrompt, temperature, maxTokens, ...rest } = params;
        const headers = {
          "Content-Type": "application/json"
        };
        if (config.apiKey) {
          headers.Authorization = `Bearer ${config.apiKey}`;
        }
        const response = await fetch(`${config.baseURL}${route}/stream`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            prompt,
            systemPrompt,
            temperature,
            maxTokens,
            ...rest
          }),
          signal: abortController.signal
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        await handleEventStream(response, handler);
      } catch (error) {
        if (error instanceof Error && error.name !== "AbortError") {
          handler({ type: "error", error });
        }
      }
    })();
    return {
      abort: () => abortController.abort(),
      completion
    };
  },
  voiceLLM: async (params, config) => {
    const { audioData, voiceSettings, context, ...rest } = params;
    const headers = {};
    if (config.apiKey) {
      headers.Authorization = `Bearer ${config.apiKey}`;
    }
    const voiceEndpoint = voiceSettings.endpoint || config.voiceRoute || "/voice";
    const fullUrl = voiceEndpoint.startsWith("http") ? voiceEndpoint : `${config.baseURL}${voiceEndpoint}`;
    const formData = new FormData();
    formData.append("audio", audioData, "recording.webm");
    formData.append("settings", JSON.stringify(voiceSettings));
    if (context) {
      formData.append("context", JSON.stringify(context));
    }
    for (const [key, value] of Object.entries(rest)) {
      if (value === void 0 || value === null) continue;
      if (typeof value === "object") {
        formData.append(key, JSON.stringify(value));
      } else {
        formData.append(key, String(value));
      }
    }
    const response = await fetch(fullUrl, {
      method: "POST",
      headers,
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Voice endpoint returned ${response.status}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType?.includes("audio")) {
      const audioBuffer = await response.arrayBuffer();
      const base64 = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));
      return {
        content: "",
        audioData: base64,
        audioFormat: contentType
      };
    } else if (contentType?.includes("application/json")) {
      const data = await response.json();
      return {
        content: data.text || data.content || "",
        transcription: data.transcription,
        audioData: data.audioData,
        audioUrl: data.audioUrl,
        audioFormat: data.audioFormat,
        usage: data.usage,
        metadata: data.metadata,
        object: data.object
      };
    } else {
      const text = await response.text();
      return {
        content: text
      };
    }
  },
  handleResponse: async (response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    return {
      content: data.text || data.content || "",
      usage: data.usage,
      metadata: {
        model: data.model,
        id: data.id
      },
      object: data.object
      // Include the structured output if present
    };
  }
};
export {
  mastraProvider
};
//# sourceMappingURL=mastra.mjs.map